ui_print("************************************");
ui_print("*        MicroG Installer 1.0      *");
ui_print("************************************");
ui_print("");
ui_print("By NammIsADev");
ui_print("");
ui_print("Installing microG companion suite...");
ui_print("This installer will install packages into /system or /system_root/system");
ui_print("");
ui_print("DO NOT FLASH THIS PACKAGE WHEN YOU ALREADY HAVE GOOGLE PLAY SERVICES!");
ui_print(""); # Added for better visual separation

# --- Optimization: Centralize partition detection and mounting ---

# Determine the correct system partition path
# This tries to be more robust by checking common system paths
# Order matters: by-name is preferred, then by-partlabel
set_partition_path("/dev/block/bootdevice/by-name/system", "/system");
if (!is_mounted("/system")) then
    set_partition_path("/dev/block/bootdevice/by-partlabel/system", "/system");
endif;

# If system is still not found or mounted, try to mount based on fstab
if (!is_mounted("/system")) then
    mount("ext4", "EMMC", "/system"); # Try mounting /system directly if not already mounted
endif;

# Check for System-as-Root (SAR) layout
# We can use getprop to check if "ro.build.system_root_image" is "true"
# This is often more reliable than trying to mount and check directories.
# If not available, fallback to the mount/test method.
set_sar_detected(false);
if (file_getprop("/system/build.prop", "ro.build.system_root_image") == "true") then
    set_sar_detected(true);
else
    # Fallback for older TWRP or devices without the prop set clearly
    # Mount to a temporary location to check for SAR without disturbing actual system
    if (mount("ext4", "EMMC", "/dev/block/bootdevice/by-name/system", "/mnt_check")) then
        run_program("/sbin/sh", "-c", "test -d /mnt_check/system/system && exit 0 || exit 1");
        if ($? == 0) then
            set_sar_detected(true);
        endif;
        unmount("/mnt_check");
    endif;
endif;

# --- Optimization: Unified Mounting and Extraction Logic ---

# Define target paths based on SAR detection
set_target_mount_point("/system");
set_target_system_path("/system"); # Default for non-SAR

if (get_sar_detected()) then
    ui_print("Detected system-as-root (SAR) layout.");
    set_target_mount_point("/system_root");
    set_target_system_path("/system_root/system");
    # Ensure /system_root is mounted for SAR
    if (!is_mounted("/system_root")) then
        if (!mount("ext4", "EMMC", "/dev/block/bootdevice/by-name/system", "/system_root")) then
            abort("ERROR: Failed to mount /system_root for SAR installation.");
        endif;
    endif;
else
    ui_print("Detected non-system-as-root layout.");
    # Ensure /system is mounted for non-SAR
    if (!is_mounted("/system")) then
        if (!mount("ext4", "EMMC", "/dev/block/bootdevice/by-name/system", "/system")) then
            abort("ERROR: Failed to mount /system for non-SAR installation.");
        endif;
    endif;
endif;

ui_print("Extracting files...");
package_extract_dir("system", get_target_system_path());

# --- Optimization: More specific permission setting ---
# Use the actual target path for permissions

ui_print("Setting permissions...");
set_perm_recursive(0, 0, 0755, 0644, get_target_system_path() + "/priv-app");
set_perm_recursive(0, 0, 0755, 0644, get_target_system_path() + "/app"); # Assuming you might have /app too
set_perm_recursive(0, 0, 0755, 0755, get_target_system_path() + "/bin"); # For any binaries
set_perm_recursive(0, 0, 0755, 0755, get_target_system_path() + "/xbin"); # For any binaries

# Unmount the relevant partition after operations
ui_print("Cleaning up...");
if (is_mounted(get_target_mount_point())) then
    unmount(get_target_mount_point());
endif;

ui_print("Installation complete. Wipe cache and enjoy!");
